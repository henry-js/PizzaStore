# Testing

Unit testing is important for software engineering for a number of reasons:

1. Guard against bugs: Unit tests should verify that your code works as expected. By integrating into the development workflow and testing automatically, developers can catch bugs early (ByteHide, 2023)[^1].
2. Protection from regression: When adding new features the use of unit tests allows for programmers to ensure pre-existing features still function as expected (jpreese, 2022)[^2], helping to avoid an the entire class of regression defects.
3. Detect code smells: Using unit tests encourages developers to encapsulate code in a way that encourages adherence to the SOLID principles.

A unit test project has been built targeting the PizzaStore.Lib class library. These tests are designed to ensure the system adheres to the specificaction.

The use of unit tests themselves also help meet the non-functional requirements, specifically regarding maintainability. Testing the important parts of code allows engineers to ensure that new updates and modifications do not break existing code (Durga Prasad Acharya, 2022)[^3].

For my tests I am using the xunit testing framework library, a more modern library than NUnit or MSTest. XUnit uses `Fact` and `Theory` attributes to make methods discoverable by the test runner, intending to be a bit more simple than the older frameworks (Vinugayathri, 2019)[^4].

## What to test

The part of the system with the most business logic is the creation and processing of orders. By testing this class thorougly I can hopefully keep business critical bugs to a minimum as I build on top of it. The `Order` and `OrderPizza` classes have been designed to use factory methods to create new instances, this makes both classes more testable, as it is considered an antipattern to have complex logic in class constructors [^5].

```cs
    [Fact]
    public void OrderShouldCorrectlySumValueOfPizzasWithVaryingToppings()
    {
        // Arrange
        IOrderService service = new OrderService(_fixture.Context);
        var customers = service.GetCustomers();
        var customer = customers.First();
        var bases = service.GetPizzaBases();
        var toppings = service.GetPizzaToppings().ToArray();

        // Act
        var orderPizzas = FakeOrders.GeneratePizzas(bases, toppings, 3);
        var order = Order.CreateNew(customer, orderPizzas);

        // Assert
        order.OrderPrice.Should().Be(orderPizzas.Sum(p => p.Price), "Order price should be the sum cost of all pizzas");
    }
```

---
[^1]: ByteHide (2023). Unit Testing with C# and .NET (Full Guide) - ByteHide Blog. [online] ByteHide Blog. Available at: [https://www.bytehide.com/blog/unit-testing-csharp].
[^2]: jpreese (2022). Best practices for writing unit tests - .NET. [online] Microsoft.com. Available at: [https://learn.microsoft.com/en-us/dotnet/core/testing/unit-testing-best-practices].
[^3]: Durga Prasad Acharya (2022). Unit Testing Explained: What It Is, Why Itâ€™s Important, and How to Get Started. [online] Geekflare. Available at: [https://geekflare.com/unit-testing-guide/].
[^4]: Vinugayathri (2019). Why Use xUnit For .NET - NUnit vs. XUnit vs. MSTest. [online] Clariontech.com. Available at: [https://www.clariontech.com/blog/why-should-you-use-xunit-a-unit-testing-framework-for-.net].
[^5]: pawar, amol (2024). Understanding Object Creation, Constructors, and Singleton Class in Java. [online] Medium. Available at: [https://blog.devgenius.io/understanding-object-creation-constructors-and-singleton-class-in-java-c055fe206a2b].
